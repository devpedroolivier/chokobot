# app/handler.py
from datetime import datetime
from collections import deque
from app.models.clientes import salvar_cliente
from app.utils.mensagens import responder_usuario, is_saudacao
from app.services.encomendas import processar_encomenda
from app.services.cafeteria import processar_cafeteria
from app.services.entregas import processar_entrega
from app.services.atendimento import processar_atendimento
from app.services.estados import (
    estados_encomenda,
    estados_entrega,
    estados_cafeteria,
    estados_atendimento,
)
from app.config import CAFETERIA_URL

# ==============================================================
# CONFIGURA√á√ïES E OP√á√ïES GLOBAIS
# ==============================================================

CANCELAR_OPCOES = ["cancelar", "sair", "parar", "desistir"]
MENU_OPCOES = ["menu", "voltar", "inicio", "principal", "bot"]
REATIVAR_BOT_OPCOES = ["voltar", "menu", "bot", "reativar", "voltar ao bot"]

# üîπ Hist√≥rico limitado de mensagens processadas (evita duplica√ß√µes da Z-API)
mensagens_processadas = deque(maxlen=2000)

from datetime import datetime, timedelta

# Hist√≥rico de mensagens recentes por telefone (para evitar reprocessamento com IDs diferentes)
ultimas_mensagens = {}


# ==============================================================
# FUN√á√ÉO PRINCIPAL
# ==============================================================

async def processar_mensagem(mensagem: dict):
    """
    Processa mensagens recebidas via webhook da Z-API.
    Inclui:
      - Filtro anti-duplica√ß√£o por messageId
      - Controle de estados (encomendas, cafeteria, entregas)
      - Comandos globais (menu, cancelar, atendimento)
    """

    # üîπ Extrai dados principais
    texto = (mensagem.get("text", {}) or {}).get("message", "")
    if texto:
        texto = texto.lower().strip()
    telefone = (mensagem.get("phone") or "").replace("+", "").strip()
    nome_cliente = mensagem.get("chatName", "Nome n√£o informado")
    msg_id = mensagem.get("id") or mensagem.get("messageId")

    if not telefone or not texto:
        print("‚ùå Dados incompletos:", mensagem)
        return

        # ==============================================================
    # ANTI-DUPLICA√á√ÉO DE WEBHOOKS Z-API (com verifica√ß√£o de conte√∫do e tempo)
    # ==============================================================
    agora = datetime.now()

    if msg_id and msg_id in mensagens_processadas:
        print(f"‚ö†Ô∏è Ignorado webhook duplicado ({msg_id}) de {telefone}")
        return
    if msg_id:
        mensagens_processadas.append(msg_id)

    # üîπ Filtro adicional: mensagem id√™ntica recebida h√° menos de 2 segundos
    ultima = ultimas_mensagens.get(telefone)
    if ultima and ultima["texto"] == texto and (agora - ultima["hora"]) < timedelta(seconds=2):
        print(f"‚ö†Ô∏è Ignorado duplicado por conte√∫do de {telefone}: '{texto}'")
        return
    ultimas_mensagens[telefone] = {"texto": texto, "hora": agora}


    # ==============================================================
    # ATENDIMENTO HUMANO
    # ==============================================================

    if telefone in estados_atendimento:
        if texto in REATIVAR_BOT_OPCOES:
            estados_atendimento.pop(telefone, None)
            await responder_usuario(
                telefone,
                "ü§ñ Bot reativado. Vamos continuar!\n"
                "1Ô∏è‚É£ Ver card√°pios\n"
                "2Ô∏è‚É£ Encomendar bolos ou tortas\n"
                "3Ô∏è‚É£ Pedidos Delivery Cafeteria\n"
                "4Ô∏è‚É£ Entregas üöö"
            )
        else:
            print(f"üë§ {telefone} em atendimento humano ‚Äî bot silencioso.")
        return

    # ==============================================================
    # CANCELAR GLOBAL
    # ==============================================================

    if texto in CANCELAR_OPCOES:
        if telefone in estados_encomenda:
            estados_encomenda.pop(telefone)
            await responder_usuario(telefone, "‚ùå Encomenda cancelada com sucesso.")
        elif telefone in estados_cafeteria:
            estados_cafeteria.pop(telefone)
            await responder_usuario(telefone, "‚ùå Pedido da cafeteria cancelado com sucesso.")
        elif telefone in estados_entrega:
            estados_entrega.pop(telefone)
            await responder_usuario(telefone, "‚ùå Solicita√ß√£o de entrega cancelada com sucesso.")
        else:
            await responder_usuario(telefone, "‚ö†Ô∏è Nenhuma opera√ß√£o em andamento para cancelar.")
        return

    # ==============================================================
    # MENU GLOBAL
    # ==============================================================

    if texto in MENU_OPCOES:
        estados_encomenda.pop(telefone, None)
        estados_cafeteria.pop(telefone, None)
        estados_entrega.pop(telefone, None)
        await responder_usuario(
            telefone,
            "üç´ *Menu Principal*\n"
            "1Ô∏è‚É£ Ver card√°pios\n"
            "2Ô∏è‚É£ Encomendar bolos ou tortas\n"
            "3Ô∏è‚É£ Pedidos Delivery Cafeteria\n"
            "4Ô∏è‚É£ Entregas üöö"
        )
        return

    # ==============================================================
    # FLUXOS PRINCIPAIS POR ESTADO
    # ==============================================================

    # üîπ Entregas
    if telefone in estados_entrega:
        estado = estados_entrega[telefone]
        resultado = await processar_entrega(telefone, texto, estado)
        estados_entrega[telefone] = estado
        if resultado == "finalizar":
            estados_entrega.pop(telefone, None)
            estados_encomenda.pop(telefone, None)
            print(f"‚úÖ DEBUG: Estados limpos para {telefone} ap√≥s finalizar entrega")
        return

    # üîπ Encomendas
    if telefone in estados_encomenda:
        estado = estados_encomenda[telefone]
        resultado = await processar_encomenda(telefone, texto, estado, nome_cliente)
        estados_encomenda[telefone] = estado  # üîπ commit seguro ap√≥s cada intera√ß√£o
        if resultado == "finalizar":
            estados_encomenda.pop(telefone, None)
        return

    # üîπ Cafeteria
    if telefone in estados_cafeteria:
        estado = estados_cafeteria[telefone]
        resultado = await processar_cafeteria(telefone, texto, estado)
        estados_cafeteria[telefone] = estado
        if resultado == "voltar_menu":
            estados_cafeteria.pop(telefone, None)
            await responder_usuario(
                telefone,
                "üç´ Ol√° novamente! Escolha uma op√ß√£o:\n"
                "1Ô∏è‚É£ Ver card√°pios\n"
                "2Ô∏è‚É£ Encomendar bolos ou tortas\n"
                "3Ô∏è‚É£ Pedidos Delivery Cafeteria\n"
                "4Ô∏è‚É£ Entregas üöö"
            )
        elif resultado == "finalizar":
            estados_cafeteria.pop(telefone, None)
        return

    # ==============================================================
    # SAUDA√á√ÉO E ENTRADA INICIAL
    # ==============================================================

    salvar_cliente(telefone, nome_cliente)

    if is_saudacao(texto):
        await responder_usuario(
            telefone,
            "üç´ Ol√°! Bem-vindo(a) √† *Chokodel√≠cia* üç´\n"
            "Sou a *Trufinha* üç¨, assistente virtual da nossa Cafeteria e Doceria!\n\n"
            "Escolha uma op√ß√£o:\n"
            "1Ô∏è‚É£ Ver card√°pios\n"
            "2Ô∏è‚É£ Encomendar bolos ou tortas\n"
            "3Ô∏è‚É£ Pedidos Delivery Cafeteria\n"
            "4Ô∏è‚É£ Entregas üöö"
        )
        return

    # ==============================================================
    # MENU PRINCIPAL (NAVEGA√á√ÉO INICIAL)
    # ==============================================================

    if texto in ["1", "card√°pio", "cardapio", "cardapios"]:
        estados_cafeteria[telefone] = {"subetapa": "aguardando_cardapio"}
        await responder_usuario(
            telefone,
            "üìã Qual card√°pio voc√™ deseja ver?\n"
            "1Ô∏è‚É£ Card√°pio Cafeteria\n"
            "2Ô∏è‚É£ Card√°pio Bolos & Tortas\n"
            "3Ô∏è‚É£ Card√°pio Doces"
        )
        return

    elif texto in ["2", "bolo", "encomendar", "encomendas", "torta", "tortas"]:
        estados_encomenda[telefone] = {"etapa": 1, "dados": {}}
        await responder_usuario(
            telefone,
            "üéÇ *Vamos come√ßar sua encomenda!*\n\n"
            "Qual linha voc√™ deseja?\n"
            "1Ô∏è‚É£ Pronta Entrega ‚Äî sabores dispon√≠veis hoje\n"
            "2Ô∏è‚É£ Monte seu bolo (B3 | B4 | B6 | B7)\n"
            "3Ô∏è‚É£ Linha Gourmet (Ingl√™s ou Redondo P6)\n"
            "4Ô∏è‚É£ Linha Mesvers√°rio ou Revela√ß√£o\n"
            "5Ô∏è‚É£ Linha Individual Baby Cake\n"
            "6Ô∏è‚É£ Tortas\n\n"
            "üì∑ Fotos e pre√ßos: https://keepo.io/boloschoko/"
        )
        return

    elif texto in ["3", "pedido", "cafeteria", "delivery"]:
        await responder_usuario(
            telefone,
            f"‚òï Os pedidos da *cafeteria* s√£o feitos pelo nosso link oficial: {CAFETERIA_URL}\n"
            "Qualquer d√∫vida, me chame aqui. üòâ"
        )
        return

    elif texto in ["4", "entrega", "informa√ß√µes de entrega", "delivery"]:
        await responder_usuario(
            telefone,
            "üöö Entregamos em *Pitangueiras-SP* (taxa R$10) *exceto zona rural*.\n"
            "Ibitiuva, zona rural ou Usina: combinar valor especial.\n"
            "Para outras regi√µes, o valor depende da dist√¢ncia (via Uber).\n"
            "Hor√°rio de entregas: 10h √†s 18h."
        )
        return

    elif texto in ["5", "atendente", "humano", "falar"]:
        await processar_atendimento(telefone, nome_cliente)
        return

    else:
        await responder_usuario(
            telefone,
            "Desculpe, n√£o entendi sua mensagem üòï\n"
            "Digite uma das op√ß√µes abaixo:\n"
            "1Ô∏è‚É£ Ver card√°pios\n"
            "2Ô∏è‚É£ Encomendar bolos ou tortas\n"
            "3Ô∏è‚É£ Pedidos Delivery Cafeteria\n"
            "4Ô∏è‚É£ Entregas üöö"
        )
